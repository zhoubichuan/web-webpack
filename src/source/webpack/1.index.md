---
lang: zh-CN
sidebarDepth: 2
meta:
  - name: description
    content: 个人总结的vuepress学习技术文档-语法
  - name: keywords
    content: vuepress,最新技术文档,vuepress语法,markdown语法
---

# Webpack 源码整体结构

解析 webpack 包进入`node_modules/webpack/bin/webpack.js`

```js
// 判断是否有安装webpack-cli、webpack-command包
const installedClis = CLIs.filter((cli) => cli.installed)

if (installedClis.length === 0) {
  // 1.没有安装webpack-cli、webpack-command这两个包，先提示错误信息需要安装webpack cli 然后指导用户安装
} else if (installedClis.length === 1) {
  // 2.安装了webpack-cli、webpack-command其中一个包
  const path = require("path")
  const pkgPath = require.resolve(`${installedClis[0].package}/package.json`)
  const pkg = require(pkgPath)
  require(path.resolve(
    //解析webpack-cli 或者 webpack-command 包
    path.dirname(pkgPath),
    pkg.bin[installedClis[0].binName]
  ))
} else {
  // 3.安装了webpack-cli、webpack-command这两个包，提示错误信息需要卸载其中一个包
}
```

解析 webpack-cli 包进入`node_modules/webpack-cli/package.json`

```json
{
  ...
  "bin": {
    "webpack-cli": "./bin/cli.js"
  },
  ...
}
```

实际上就是

```js
require("node_modules/webpack-cli/bin/cli.js")
```

解析 `node_modules/webpack-cli/bin/cli.js`

```js
// 存在webpack这个包
if (utils.packageExists("webpack")) {
  runCLI(process.argv, originalModuleCompile)
}
```

解析 `node_modules/webpack-cli/lib/bootstrap.js`

```js
const runCLI = async (args, originalModuleCompile) => {
  try {
    // 首先实例化WebpackCLI
    const cli = new WebpackCLI()
    cli._originalModuleCompile = originalModuleCompile
    // 然后调用上面的run方法
    await cli.run(args)
  } catch (error) {
    utils.logger.error(error)
    process.exit(2)
  }
}
```

解析 `node_modules/webpack-cli/lib/webpack-cli.js`拿到 WebpackCLI 实现 cli.run

```js
class WebpackCLI {
  constructor() {
    // 实例化WebpackCLI时，会解析webpack这个包
    this.webpack = require(process.env.WEBPACK_PACKAGE || "webpack")
  }
  // cli.run时会执行以下逻辑
  async run(args, parseOptions) {
    const loadCommandByName = async (commandName, allowToInstall = false) => {
      await this.runWebpack(options, isWatchCommandUsed)
    }
    this.program.action(async (options, program) => {
      await loadCommandByName(commandToRun, true)
    })
  }

  async runWebpack(options, isWatchCommand) {
    const callback = (error, stats) => {}
    compiler = await this.createCompiler(options, callback)
  }
  async createCompiler(options, callback) {
    this.applyNodeEnv(options)

    let config = await this.resolveConfig(options)

    config = await this.applyOptions(config, options)
    config = await this.applyCLIPlugin(config, options)

    let compiler

    compiler = this.webpack(config.options, callback)

    return compiler
  }
}
```

实例化 WebpackCLI 时,解析`node_modules/webpack/lib/webpack.js`

```js
const webpack = (options, callback) => {
  let compiler
  if (Array.isArray(options)) {
  } else if (typeof options === "object") {
    // 用户设置的配置和默认配置合并
    options = new WebpackOptionsDefaulter().process(options)
    // Compiler 阶段
    compiler = new Compiler(options.context)
    compiler.options = options
    // 配置全局api插件
    new NodeEnvironmentPlugin({
      infrastructureLogging: options.infrastructureLogging,
    }).apply(compiler)
    // 执行我们在配置文件中配置的所有插件
    if (options.plugins && Array.isArray(options.plugins)) {
      for (const plugin of options.plugins) {
        if (typeof plugin === "function") {
          plugin.call(compiler, compiler)
        } else {
          plugin.apply(compiler)
        }
      }
    }
    compiler.hooks.environment.call()
    compiler.hooks.afterEnvironment.call()
    //开启默认的所有插件
    compiler.options = new WebpackOptionsApply().process(options, compiler)
  }
  return compiler
}
```

./Compiler

```js
class Compiler extends Tapable {
  run(callback) {
    if (this.running) return callback(new ConcurrentCompilationError())
    //整个打包编译执行完毕回调
    const finalCallback = (err, stats) => {
      this.running = false

      if (err) {
        this.hooks.failed.call(err)
      }

      if (callback !== undefined) return callback(err, stats)
    }

    const startTime = Date.now()

    this.running = true
    //编译完毕回调
    const onCompiled = (err, compilation) => {
      if (err) return finalCallback(err)

      if (this.hooks.shouldEmit.call(compilation) === false) {
        const stats = new Stats(compilation)
        stats.startTime = startTime
        stats.endTime = Date.now()
        this.hooks.done.callAsync(stats, (err) => {
          if (err) return finalCallback(err)
          return finalCallback(null, stats)
        })
        return
      }
      //执行打包操作
      this.emitAssets(compilation, (err) => {
        if (err) return finalCallback(err)

        if (compilation.hooks.needAdditionalPass.call()) {
          compilation.needAdditionalPass = true

          const stats = new Stats(compilation)
          stats.startTime = startTime
          stats.endTime = Date.now()
          this.hooks.done.callAsync(stats, (err) => {
            if (err) return finalCallback(err)

            this.hooks.additionalPass.callAsync((err) => {
              if (err) return finalCallback(err)
              this.compile(onCompiled)
            })
          })
          return
        }

        this.emitRecords((err) => {
          if (err) return finalCallback(err)

          const stats = new Stats(compilation)
          stats.startTime = startTime
          stats.endTime = Date.now()
          this.hooks.done.callAsync(stats, (err) => {
            if (err) return finalCallback(err)
            return finalCallback(null, stats)
          })
        })
      })
    }

    this.hooks.beforeRun.callAsync(this, (err) => {
      this.compile(onCompiled)
    })
  }
  //编译
	compile(callback) {
    //创建编译器的参数
		const params = this.newCompilationParams();
		this.hooks.beforeCompile.callAsync(params, err => {
			if (err) return callback(err);

			this.hooks.compile.call(params);
      //创建一个编译器
			const compilation = this.newCompilation(params);
      //执行前面## EntryPlugin.js注册的make钩子函数并把编译器传递给插件
			this.hooks.make.callAsync(compilation, err => {
				if (err) return callback(err);

				compilation.finish(err => {
					if (err) return callback(err);

					compilation.seal(err => {
						if (err) return callback(err);

						this.hooks.afterCompile.callAsync(compilation, err => {
							if (err) return callback(err);

							return callback(null, compilation);
						});
					});
				});
			});
		});
	}
  //创建编译器的参数
	newCompilationParams() {
		const params = {
      //创建一个模块工厂
			normalModuleFactory: this.createNormalModuleFactory(),
      //创建一个上下文工厂
			contextModuleFactory: this.createContextModuleFactory(),
			compilationDependencies: new Set()
		};
		return params;
	}
  //创建模块工厂
	createNormalModuleFactory() {
		const normalModuleFactory = new NormalModuleFactory(
			this.options.context,
			this.resolverFactory,
			this.options.module || {}
		);
		this.hooks.normalModuleFactory.call(normalModuleFactory);
		return normalModuleFactory;
	}
}
```

- ./node/NodeEnvironmentPlugin

```js
class NodeEnvironmentPlugin {
  constructor(options) {
    this.options = options || {}
  }

  apply(compiler) {
    compiler.infrastructureLogger = createConsoleLogger(
      Object.assign(
        {
          level: "info",
          debug: false,
          console: nodeConsole,
        },
        this.options.infrastructureLogging
      )
    )
    compiler.inputFileSystem = new CachedInputFileSystem(
      new NodeJsInputFileSystem(),
      60000
    )
    const inputFileSystem = compiler.inputFileSystem
    compiler.outputFileSystem = new NodeOutputFileSystem()
    compiler.watchFileSystem = new NodeWatchFileSystem(compiler.inputFileSystem)
    compiler.hooks.beforeRun.tap("NodeEnvironmentPlugin", (compiler) => {
      if (compiler.inputFileSystem === inputFileSystem) inputFileSystem.purge()
    })
  }
}
```

- ./WebpackOptionsApply

```js
class WebpackOptionsApply extends OptionsApply {
  process(options, compiler) {
    //入口文件插件注册
    new EntryOptionPlugin().apply(compiler)
    //调用入口文件插件注册钩子函数
    compiler.hooks.entryOption.call(options.context, options.entry)
  }
}
```

- ./EntryOptionPlugin.js

```js
const itemToPlugin = (context, item, name) => {
  if (Array.isArray(item)) {
    return new MultiEntryPlugin(context, item, name) // 多页应用
  }
  return new SingleEntryPlugin(context, item, name) // 单页应用
}
class EntryOptionPlugin {
  apply(compiler) {
    compiler.hooks.entryOption.tap("EntryOptionPlugin", (context, entry) => {
      if (typeof entry === "string" || Array.isArray(entry)) {
        itemToPlugin(context, entry, "main").apply(compiler)
      } else if (typeof entry === "object") {
        for (const name of Object.keys(entry)) {
          itemToPlugin(context, entry[name], name).apply(compiler)
        }
      } else if (typeof entry === "function") {
        new DynamicEntryPlugin(context, entry).apply(compiler)
      }
      return true
    })
  }
}
```

- ./SingleEntryPlugin.js

```js
class SingleEntryPlugin {
  constructor(context, entry, name) {
    this.context = context
    this.entry = entry
    this.name = name
  }

  apply(compiler) {
    compiler.hooks.compilation.tap(
      "SingleEntryPlugin",
      (compilation, { normalModuleFactory }) => {
        compilation.dependencyFactories.set(
          SingleEntryDependency,
          normalModuleFactory
        )
      }
    )

    compiler.hooks.make.tapAsync(
      "SingleEntryPlugin",
      (compilation, callback) => {
        const { entry, name, context } = this

        const dep = SingleEntryPlugin.createDependency(entry, name)
        compilation.addEntry(context, dep, name, callback)
      }
    )
  }

  static createDependency(entry, name) {
    const dep = new SingleEntryDependency(entry)
    dep.loc = { name }
    return dep
  }
}
```

- cli.run

```js
if (callback) {
  if (
    options.watch === true ||
    (Array.isArray(options) && options.some((o) => o.watch))
  ) {
    const watchOptions = Array.isArray(options)
      ? options.map((o) => o.watchOptions || {})
      : options.watchOptions || {}
    return compiler.watch(watchOptions, callback)
  }
  compiler.run(callback)
}
```

## entry-options

option 初始化，创建 compiler、compilation 对象、初始化 webpack 参数等

### 创建 compiler

### 创建 compilation 对象

### 初始化 webpack 参数

## compiler

开始编译，主要是加载入口文件，添加入口 module

## make

分析入口文件创建模块对象，主要做模块的解析，获取当前模块的 request、loaders、源码等信息

## build-module

构建模块

## after-compile

完成所有模块构建，结束编译过程

## emit

Compiler 开始输出生成 assets，插件有最后的机会修改 assets

## after-emit

输出完成
